```
1.2lemon_test1_ep20.zarr
├── action
├── eef_qpos
├── observations
├── point_cloud
├── qpos
└── .zgroup
```
this is what the structure from the sample looks like.

this is the correct one:
```
zarr文件/
├── data/           # 实际数据放在这里
│   ├── agent_pos
│   ├── action
│   └── point_cloud
├── meta/           # 元数据放在这里
│   ├── episode_ends
│   └── keys
└── .zgroup
```

```
# save as add_meta_to_zarr.py
import zarr
import numpy as np
from pathlib import Path

def add_meta_to_zarr(zarr_path):
    """添加必要的meta组到zarr文件"""
    
    # 打开现有的zarr文件
    root = zarr.open(zarr_path, mode='r+')
    
    # 检查是否已经有meta组
    if 'meta' in root:
        print(f"文件 {zarr_path} 已包含meta组")
        return
    
    # 创建meta组
    meta_group = root.create_group('meta')
    
    # 添加必要的元数据
    # 1. 计算episode_ends（假设整个数据是一个episode）
    total_steps = root['action'].shape[0]
    meta_group.create_dataset('episode_ends', data=[total_steps], dtype='int64')
    
    # 2. 添加其他元数据
    meta_group.attrs.update({
        'total_steps': total_steps,
        'n_episodes': 1,
        'episode_lengths': [total_steps],
    })
    
    # 3. 为每个数据字段添加键
    meta_group.create_dataset('keys', data=['agent_pos', 'action', 'point_cloud'], dtype='<U20')
    
    print(f"成功添加meta组到 {zarr_path}")
    print(f"  episode_ends: {[total_steps]}")
    print(f"  n_episodes: 1")
    print(f"  keys: ['agent_pos', 'action', 'point_cloud']")

# 运行
if __name__ == "__main__":
    zarr_path = "data/1.2lemon_test1_ep20.zarr"
    add_meta_to_zarr(zarr_path)
    
    # 验证结构
    print("\n验证zarr结构:")
    root = zarr.open(zarr_path, mode='r')
    root.tree()
```    
add this to restructure the tree for meta.

add this for tree data(note that this is more than just adding a folder outside):
```
# 修复Zarr结构的脚本
python -c "
import zarr
import numpy as np
import shutil
import os
from pathlib import Path

# 您的Zarr文件路径
zarr_path = 'data/1.2lemon_test1_ep20.zarr'

print(f'修复Zarr文件: {zarr_path}')

# 1. 备份原始数据
print('1. 备份原始数据...')
root = zarr.open(zarr_path, mode='r')

# 读取现有数据
action_data = root['action'][:] if 'action' in root else None
agent_pos_data = root['agent_pos'][:] if 'agent_pos' in root else None
point_cloud_data = root['point_cloud'][:] if 'point_cloud' in root else None

# 检查数据是否存在
if action_data is None or agent_pos_data is None or point_cloud_data is None:
    print('错误: 缺少必要的数据集')
    exit(1)

# 2. 删除旧的Zarr文件夹
print('2. 删除旧的Zarr结构...')
if os.path.exists(zarr_path):
    shutil.rmtree(zarr_path)

# 3. 用Zarr API重新创建正确的结构
print('3. 创建正确的Zarr结构...')
store = zarr.DirectoryStore(zarr_path)
root = zarr.group(store=store, overwrite=True)

# 创建data组
data_group = root.create_group('data')

# 在data组下创建数据集
data_group.create_dataset('action', data=action_data, chunks=(100, 7), dtype='float64')
data_group.create_dataset('agent_pos', data=agent_pos_data, chunks=(100, 7), dtype='float64')
data_group.create_dataset('point_cloud', data=point_cloud_data, chunks=(100, 1024, 3), dtype='float32')

# 创建meta组
meta_group = root.create_group('meta')

# 计算episode_ends（假设整个数据是一个episode）
total_steps = len(action_data)
episode_ends = [total_steps]

# 在meta组下创建episode_ends数据集
meta_group.create_dataset('episode_ends', data=episode_ends, dtype='int64')

# 在meta组下创建keys数据集
keys = ['agent_pos', 'action', 'point_cloud']
meta_group.create_dataset('keys', data=keys, dtype='<U20')

# 添加元数据属性
meta_group.attrs['total_steps'] = total_steps
meta_group.attrs['n_episodes'] = 1
meta_group.attrs['episode_lengths'] = episode_ends

print('4. 验证新的Zarr结构...')
root_new = zarr.open(zarr_path, mode='r')
print('Zarr树结构:')
root_new.tree()

print('\\n数据形状:')
print(f'  data/action: {root_new[\"data/action\"].shape}')
print(f'  data/agent_pos: {root_new[\"data/agent_pos\"].shape}')
print(f'  data/point_cloud: {root_new[\"data/point_cloud\"].shape}')
print(f'  meta/episode_ends: {root_new[\"meta/episode_ends\"][:]}')
print(f'  meta/keys: {root_new[\"meta/keys\"][:]}')

print('\\n✅ Zarr文件修复完成！')
"
```